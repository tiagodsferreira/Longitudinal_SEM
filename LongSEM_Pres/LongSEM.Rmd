---
title: "Modelos de Equações Estruturais Longitudinais"
author: "Tiago Ferreira"
subtitle: "Faculdade de Psicologia e de Ciências da Educação - UP"
output:
  ioslides_presentation: 
    widescreen: true
  beamer_presentation: default
  slidy_presentation: default
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style>
pre {
    line-height: 1.2em;
    font-size: 16px;
}
</style>
```
```{r, setup, include=FALSE}
library("datasets")  
library("lattice")
library("psych")
library("Hmisc")
library("ggplot2")
library("knitr")
library("png")
library("lavaan")
library("semTools")
library("knitr")
library("kableExtra")
library("semPlot")
library("GGally")


# Some customization.  You can alter or delete as desired (if you know what you are doing).
knitr::opts_chunk$set(
  tidy=FALSE,     # display code as typed
  size="medium")   # slightly smaller font for code
```

# AGENDA \| Modelos de Equações Estruturais Longitudinais {.smaller}

::: gray2
- **Análise fatorial confirmatória com dados longitudinais**  
- **Invariância de Medida (MI) longitudinal**
- **Exercício prático - Parte 1**  
- **Modelos de Crescimento Latente (LGC)**  
- **Exercício prático - Parte 2**  
:::

# Análise fatorial confirmatória com dados longitudinais

## CFA e Modelo de medida (recap)
A CFA permite testar se um modelo de medida pré-existente se ajusta aos nossos dados  

- Este modelo representa as relações entre uma ou mais variáveis latentes ou fatores e os seus indicadores observados   
  - A CFA foi abordada anteriormente com dados transversais
  - Neste módulo, vamos ver como aplicar a CFA a dados longitudinais


## Exemplo: Dois Fatores, Seis Indicadores
- **Matriz de Covariância Implícita:**

```{r, echo=FALSE, fig.width=10, fig.height=7, out.width="80%"}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\ConfirmatoryFactorAnalysis\\files\\figures\\cfamodel.png")
```


## CFA Multigrupo
### CFA multigrupo permite avaliar a medida em um certo um modelo de medida se ajusta a subgrupos da população
  - ex.: género, coortes, contextos culturais

- Utiliza-se para avaliar **invariância de medida**\  
- Essencial para comparações válidas entre grupos\
- A CFA longitudinal é uma extensão da CFA multigrupo\


## CFA com dados longitudinais
### Extensão do modelo CFA multigrupo  

```{r, echo=FALSE, fig.width=10, fig.height=7, out.width="100%"}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\MeasurementInvariance\\figures\\MI_step0.png")
```


## CFA Longitudinal

### A CFA longitudinal permite testar se a estrutura de um modelo de medida se mantém estável ao longo do tempo

- Cada momento de avaliação é tratado como um "grupo" no modelo multigrupo  
- Avalia se os construtos latentes são **medidos de forma consistente ao longo do tempo**  
- Essencial para análises longitudinais como:
  - Modelos de crescimento latente (LGM)
  - Modelos de painel
  - ...


## CFA Longitudinal
```{r, echo=FALSE, fig.width=6, fig.height=4, out.width="90%"}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\CFA_long.png")
```




## CFA Longitudinal - implementação
Para as análises seguintes recorremos a uma base de dados usada por Todd Little no livro:   
  - Little, T. (2013). *Longitudinal structural equation modeling*. New York, NY: Guilford Press.  

Este livro é um bom recurso para conhecer e aplicar procedimentos SEM a dados longitudinais    

```{r, out.width = "200px", echo = FALSE}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\Little.jpg")
```



## Importação e exploração inicial dos dados
```{r, echo=TRUE, eval=FALSE, include=FALSE}

## read sufficient statistics from example data file
mymeans <- scan("C:\\Users\\tiago\\Google Drive\\FPCEUP\\R trainning\\PDPsi\\R crash course_DATA\\L3.MoodLong.dat", skip=0, nlines=1)
mysds <- scan("C:\\Users\\tiago\\Google Drive\\FPCEUP\\R trainning\\PDPsi\\R crash course_DATA\\L3.MoodLong.dat", skip=1, nlines=1)
mycors <- scan("C:\\Users\\tiago\\Google Drive\\FPCEUP\\R trainning\\PDPsi\\R crash course_DATA\\L3.MoodLong.dat", skip=2)


##push that into correlation matrix, lower triangle
xindex <- c(0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171)
posaff <- outer(1:18, 1:18, FUN = function(X, Y) ifelse(Y <= X, mycors[Y + xindex[X]], 0))

mynames <- c("PosAFF11", "PosAFF21", "PosAFF31", "NegAFF11", "NegAFF21", "NegAFF31",
						 "PosAFF12", "PosAFF22", "PosAFF32", "NegAFF12", "NegAFF22", "NegAFF32",
						 "PosAFF13", "PosAFF23", "PosAFF33", "NegAFF13", "NegAFF23", "NegAFF33")
colnames(posaff) <- mynames
rownames(posaff) <- mynames
?outer
### now create the covariance matrix
myvarcov <- outer(mysds, mysds, FUN="*")
mycov <- posaff * myvarcov

## sample size
nObs <- 368

## Creating data mood
library(MASS)
DB_mood <- mvrnorm(n = nObs, mu = mymeans, Sigma = mycov, empirical = TRUE)
colMeans(DB_mood)
cor(DB_mood)
head(DB_mood)


summary(DB_mood)
class(DB_mood)
DF_mood <- as.data.frame(DB_mood)
head(round(DF_mood,2))
summary(DF_mood)

names(DF_mood)
DF_mood[,c(1:3, 7:9, 13:15)][DF_mood[, c(1:3, 7:9, 13:15)] < 1] <- 1
DF_mood[,c(4:6, 10:12, 16:18)][DF_mood[, c(4:6, 10:12, 16:18)] < 0] <- 0

row.names(DF_mood)
?write.csv
write.csv(DF_mood, "G:\\My Drive\\FPCEUP\\R trainning\\GitRepo\\Longitudinal SEM\\Longitudinal_SEM\\LongSEM_Data\\df_mood.csv", row.names=FALSE)
```

Podemos importar a base de dados para o R através do seguinte código
```{r, echo=TRUE}
DF_mood <- read.csv("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Data\\df_mood.csv")
names(DF_mood)
```

```{r, eval=FALSE}
str(DF_mood)
```

*Esta BD contem dados de 368 estudantes (50% rapazes) recolhidos em quatro momentos de avaliação, entre o 6º e 9º ano de escolaridade. Foram recolhidos indicadores de humor negativo (e.g., depressão e solidão) e humor positivo (e.g., auto-avaliação positiva e proximidade aos outros)*  


## Estatística descritiva  
```{r}
library(psych) # se necessário: install.packages("psych")
psych::describe(DF_mood[ ,1:6])
```

## Visualização de dados 
```{r}
library(ggplot2) # se necessário: install.packages("ggplot2")
DF_pos <- data.frame(var=c(rep("PosAFF_1", 368), rep("PosAFF_2", 368), rep("PosAFF_3", 368)), 
                     value = c(DF_mood$PosAFF11, DF_mood$PosAFF21, DF_mood$PosAFF31))
ggplot(DF_pos, aes(x=value)) +
  geom_histogram(aes(fill=var),color="grey80", binwidth = 0.4) + facet_grid(var~.)
```

## Visualização de dados 
```{r}
DF_neg <- data.frame(var=c(rep("NegAFF_1", 368), rep("NegAFF_2", 368), rep("NegAFF_3", 368)), 
                     value = c(DF_mood$NegAFF11, DF_mood$NegAFF21, DF_mood$NegAFF31))
ggplot(DF_neg, aes(x=value)) +
  geom_histogram(aes(fill=var),color="grey80", binwidth = 0.4) + facet_grid(var~.)
```

## Modelo CFA longitudinal - especificação
O seguinte código representa a estrutura fatorial de um modelo com:  
  - 2 VL, humor positivo e humor negativo  
  - 3 indicadores por VL  
  - 3 momentos de avaliação  

Aspeto diferenciador: **correlações entre resíduos dos mesmos indicadores avaliados em momentos diferentes**    
  - Existência de variabilidade especifica ao item que é partilhada entre os diferentes momentos de avaliação  

*NOTA. Estas correlações devem ser mantidas no modelo mesmo que não sejam significativas*  


## Modelo CFA longitudinal - especificação

```{r, echo=FALSE, fig.width=7, fig.height=9, out.width="100%"}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\CFA_long_little.png")
```


## Modelo CFA longitudinal (lavaan)
A seguinte sintaxe especifica o modelo:  
  - Como anteriormente, as VL são definidas pelo operador **=~**
```{r}
modelo.7 <- "
# Definir variáveis latentes para os 3 momentos
Pos_T1 =~ PosAFF11 + PosAFF21 + PosAFF31
Pos_T2 =~ PosAFF12 + PosAFF22 + PosAFF32
Pos_T3 =~ PosAFF13 + PosAFF23 + PosAFF33

Neg_T1 =~ NegAFF11 + NegAFF21 + NegAFF31
Neg_T2 =~ NegAFF12 + NegAFF22 + NegAFF32
Neg_T3 =~ NegAFF13 + NegAFF23 + NegAFF33
				
# Correlações entre resíduos ao longo do tempo
PosAFF11 ~~ PosAFF12 + PosAFF13; PosAFF12 ~~ PosAFF13
PosAFF21 ~~ PosAFF22 + PosAFF23; PosAFF22 ~~ PosAFF23
PosAFF31 ~~ PosAFF32 + PosAFF33; PosAFF32 ~~ PosAFF33
				
NegAFF11 ~~ NegAFF12 + NegAFF13; NegAFF12 ~~ NegAFF13
NegAFF21 ~~ NegAFF22 + NegAFF23; NegAFF22 ~~ NegAFF23
NegAFF31 ~~ NegAFF32 + NegAFF33; NegAFF32 ~~ NegAFF33
"
fit.7 <- cfa(modelo.7, data = DF_mood, meanstructure=T, std.lv=T)
```


## Modelo CFA longitudinal (avaliação)
```{r, eval=FALSE}
summary(fit.7, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)
fitMeasures(fit.7)
reliability(fit.7)
semTools::clipboard(fit.7)
```

```{r, echo=F}
semPaths(fit.7, whatLabels="std", title = FALSE, curvePivot = TRUE, layout="tree", intercepts=T, rotation=2, nCharNodes=0, sizeMan=3, sizeLat= 5, residuals=T, exoVar=F, edge.color=9)
title("Análise Fatorial Confirmatória", line = 2)
``` 


# Invariância de Medida (MI) longitudinal

## O que é MI (recap))?
### Teste formal do pressuposto de equivalência entre medições\
- *Será que os construtos em análise são comparáveis entre condições?*

### Geralmente conduzida por meio da **CFA Multigrupo** (Meredith, 1993)
- Neste contexto, parâmetros podem ser fixados como iguais entre grupos

### Níveis de MI 
(1) **Invariância Configural** - os grupos interpretam o construto de forma semelhante;  
(2) **Invariância Métrica** - os itens têm o mesmo peso;  
(3) **Invariância Escalar** - os items têm a mesma "dificuldade";  
(4) **Invariância Estrita** - os items têm a mesma precisão.  


## Comparação de modelos
```{r, echo=FALSE, fig.width=1, fig.height=1, out.width="80%"}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\MeasurementInvariance\\figures\\nestedmodels.png")
```


## Comparação de modelos encaixados

### O Likelihood Ratio Test (**LRT**) é um teste estatístico para comparar dois modelos encaixados
- avalia se **o modelo mais restrito (com menos parâmetros) se ajusta aos dados significativamente pior do que o modelo menos restrito**
- permite testar formalmente diferenças no ajustadamento de modelos encaixados

###  Outras métricas de comparação de modelos (Cheung & Rensvold, 2002)
  - **ΔCFI < 0.01**
  - **ΔRMSEA < 0.015**
  - **ΔSRMR < 0.03**


## O que é MI Longitudinal?

### Refere-se à estabilidade das propriedades psicométricas de um instrumento ao longo do tempo

### Garante que **mudanças nos valores da variável latentes** refletem mudanças reais no construto    
*e não alterações na forma como o construto é medido*
  
### Baseia-se na lógica da CFA multigrupo, onde os "grupos" são os diferentes **momentos de avaliação**



## Porquê testar invariância longitudinal?
### Sem invariância, não podemos comparar **valores fatoriais**, **tendências de crescimento** ou **efeitos longitudinais** de forma válida 

### Testar invariância permite:  
- Avaliar estabilidade do construto\  
- Identificar mudanças reais nos participantes\  
- Garantir a validade de modelos de crescimento e trajetórias latentes\

### Será o modelo de medida equivalente entre grupos ou momentos de avaliação?   
*modelos longitudinais assumem o pressuposto da invariância de medida*   



## Níveis de Invariância Longitudinal

Comparação de modelos aninhados, com um número crescente de parâmetros constrangidos:    
  1. *Configuracional* - Mesma estrutura fatorial ao longo do tempo    
  2. *Fraca ou Métrica* - Pesos fatoriais (loadings) constantes    
  3. *Forte ou Escalar* - Loadings e interceptos constantes  
  4. *Estrita* - loadings, interceptos e resíduos dos itens constantes  

- **Estes níveis são testados sequencialmente usando CFA multigrupo.** 
  - *O modelo mais simples serve de base ao teste da MI*



## MI longitudinal passo a passo?

### Usamos CFA multigrupo com **restrições progressivas**:\
- Primeiro modelo livre (configural)\
- Depois adicionam-se restrições métricas, escalares, etc.\

### Avaliamos mudança no ajuste do modelo:\
- $\Delta{CFI}$, $\Delta{RMSEA}$, $\Delta\chi^2$\

### Ferramentas comuns:\
- lavaan em R\
- Mplus\
- AMOS\



## IM Longitudinal (implementação no lavaan) 

Existem várias formas de implementar a MI longitudinal no lavaan.  

### Definindo o modelo de forma explícita e depois adicionando as restrições necessárias para cada nível de invariância (recomendada)
-  Esta abordagem oferece controle  sobre o processo de modelagem, permitindo especificar manualmente as restrições necessárias para cada nível de invariância.

### Através da função **measEq.syntax()** do pacote semTools, que permite especificar os modelos de mais automática
- Esta função automatiza a geração da sintaxe do modelo para testar diferentes níveis de invariância, simplificando o processo e reduzindo a possibilidade de erros manuais.

## Pacotes necessárias
```{r}
library(lavaan) # se necessário: install.packages("lavaan")
library(semTools) # se necessário: install.packages("semTools")
library(semPlot) # se necessário: install.packages("semPlot")
```


## Modelo Configuracional - especificação

```{r}
modelo.conf <- "
# Definir variáveis latentes para os 3 momentos
Pos_T1 =~ PosAFF11 + PosAFF21 + PosAFF31 
Pos_T2 =~ PosAFF12 + PosAFF22 + PosAFF32 
Pos_T3 =~ PosAFF13 + PosAFF23 + PosAFF33
Neg_T1 =~ NegAFF11 + NegAFF21 + NegAFF31 
Neg_T2 =~ NegAFF12 + NegAFF22 + NegAFF32 
Neg_T3 =~ NegAFF13 + NegAFF23 + NegAFF33

# Correlações entre resíduos ao longo do tempo
PosAFF11 ~~ PosAFF12 + PosAFF13; PosAFF12 ~~ PosAFF13; 
PosAFF21 ~~ PosAFF22 + PosAFF23; PosAFF22 ~~ PosAFF23; 
PosAFF31 ~~ PosAFF32 + PosAFF33; PosAFF32 ~~ PosAFF33
NegAFF11 ~~ NegAFF12 + NegAFF13; NegAFF12 ~~ NegAFF13; 
NegAFF21 ~~ NegAFF22 + NegAFF23; NegAFF22 ~~ NegAFF23; 
NegAFF31 ~~ NegAFF32 + NegAFF33; NegAFF32 ~~ NegAFF33
"
```

## IM Configuracional - estimação

### Estimar o modelo como habitualmente, com a função **cfa()** do lavaan

```{r, }
fit.conf <- cfa(modelo.conf, data = DF_mood, std.lv = T, missing = "fiml", estimator="MLR")
# summary(fit.conf, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)
all_params <- parameterEstimates(fit.conf, standardized = TRUE, rsquare = TRUE)
head(all_params[all_params$op == "=~", ])
```

## IM Configuracional - avaliação
```{r}
fitMeasures(fit.conf, c("chisq.scaled", "df.scaled", "pvalue.scaled", "rmsea.robust",
                        "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "cfi.robust",
                        "tli.robust", "srmr_mplus"))
```


## IM Métrica - especificação
### O modelo métrico é o mesmo que o configuracional, mas com a adição de restrições de igualdade nos loadings

```{r}
modelo.metric <- "
# Definir variáveis latentes para os 3 momentos
Pos_T1 =~ L1.1*PosAFF11 + L1.2*PosAFF21 + L1.3*PosAFF31 
Pos_T2 =~ L1.1*PosAFF12 + L1.2*PosAFF22 + L1.3*PosAFF32 
Pos_T3 =~ L1.1*PosAFF13 + L1.2*PosAFF23 + L1.3*PosAFF33
Neg_T1 =~ L2.1*NegAFF11 + L2.2*NegAFF21 + L2.3*NegAFF31 
Neg_T2 =~ L2.1*NegAFF12 + L2.2*NegAFF22 + L2.3*NegAFF32 
Neg_T3 =~ L2.1*NegAFF13 + L2.2*NegAFF23 + L2.3*NegAFF33

# Correlações entre resíduos ao longo do tempo
PosAFF11 ~~ PosAFF12 + PosAFF13; PosAFF12 ~~ PosAFF13; 
PosAFF21 ~~ PosAFF22 + PosAFF23; PosAFF22 ~~ PosAFF23; 
PosAFF31 ~~ PosAFF32 + PosAFF33; PosAFF32 ~~ PosAFF33
NegAFF11 ~~ NegAFF12 + NegAFF13; NegAFF12 ~~ NegAFF13; 
NegAFF21 ~~ NegAFF22 + NegAFF23; NegAFF22 ~~ NegAFF23; 
NegAFF31 ~~ NegAFF32 + NegAFF33; NegAFF32 ~~ NegAFF33

# Factors identification through reference measurement T1
Pos_T1 ~~ 1*Pos_T1; Pos_T2 ~~ NA*Pos_T2; Pos_T3 ~~ NA*Pos_T3
Neg_T1 ~~ Neg_T1; Neg_T2 ~~ NA*Neg_T2; Neg_T3 ~~ NA*Neg_T3
"
```

## IM Métrica - estimação
```{r}
fit.metric <- cfa(modelo.metric, data = DF_mood, std.lv = T, missing = "fiml", estimator="MLR")
# summary(fit.metric, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)
all_params <- parameterEstimates(fit.metric, standardized = TRUE, rsquare = TRUE)
head(all_params[all_params$op == "=~", ])
```

## IM Métrica - avaliação
```{r}
fitMeasures(fit.metric, c("chisq.scaled", "df.scaled", "pvalue.scaled", "rmsea.robust",
                        "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "cfi.robust",
                        "tli.robust", "srmr_mplus"))
```

## IM Escalar - especificação
```{r}
modelo.scalar <- "
# Definir variáveis latentes para os 3 momentos
Pos_T1 =~ L1.1*PosAFF11 + L1.2*PosAFF21 + L1.3*PosAFF31; Pos_T2 =~ L1.1*PosAFF12 + L1.2*PosAFF22 + L1.3*PosAFF32; Pos_T3 =~ L1.1*PosAFF13 + L1.2*PosAFF23 + L1.3*PosAFF33
Neg_T1 =~ L2.1*NegAFF11 + L2.2*NegAFF21 + L2.3*NegAFF31; Neg_T2 =~ L2.1*NegAFF12 + L2.2*NegAFF22 + L2.3*NegAFF32; Neg_T3 =~ L2.1*NegAFF13 + L2.2*NegAFF23 + L2.3*NegAFF33

# Correlações entre resíduos ao longo do tempo
PosAFF11 ~~ PosAFF12 + PosAFF13; PosAFF12 ~~ PosAFF13; PosAFF21 ~~ PosAFF22 + PosAFF23; PosAFF22 ~~ PosAFF23; PosAFF31 ~~ PosAFF32 + PosAFF33; PosAFF32 ~~ PosAFF33; NegAFF11 ~~ NegAFF12 + NegAFF13; NegAFF12 ~~ NegAFF13; NegAFF21 ~~ NegAFF22 + NegAFF23; NegAFF22 ~~ NegAFF23; NegAFF31 ~~ NegAFF32 + NegAFF33; NegAFF32 ~~ NegAFF33

# Factors identification through reference measurement T1
Pos_T1 ~~ 1*Pos_T1; Pos_T2 ~~ NA*Pos_T2; Pos_T3 ~~ NA*Pos_T3
Neg_T1 ~~ Neg_T1; Neg_T2 ~~ NA*Neg_T2; Neg_T3 ~~ NA*Neg_T3

#equal intercepts
PosAFF11 ~ nu1.1*1; PosAFF12 ~ nu1.1*1; PosAFF13 ~ nu1.1*1
PosAFF21 ~ nu1.2*1; PosAFF22 ~ nu1.2*1; PosAFF23 ~ nu1.2*1
PosAFF31 ~ nu1.3*1; PosAFF32 ~ nu1.3*1; PosAFF33 ~ nu1.3*1
NegAFF11 ~ nu2.1*1; NegAFF12 ~ nu2.1*1; NegAFF13 ~ nu2.1*1
NegAFF21 ~ nu2.2*1; NegAFF22 ~ nu2.2*1; NegAFF23 ~ nu2.2*1
NegAFF31 ~ nu2.3*1; NegAFF32 ~ nu2.3*1; NegAFF33 ~ nu2.3*1

# Factors identification (mean) through reference measurment (T1)
Pos_T1 ~ 0*1; Pos_T2 ~ NA*1; Pos_T3 ~ NA*1
Neg_T1 ~ 0*1; Neg_T2 ~ NA*1; Neg_T3 ~ NA*1
"
```

## IM Escalar - estimação
```{r}
fit.scalar <- cfa(modelo.scalar, data = DF_mood, std.lv = T, missing = "fiml", estimator="MLR")
# summary(fit.scalar, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)
all_params <- parameterEstimates(fit.conf, standardized = TRUE, rsquare = TRUE)
head(all_params[all_params$op == "~1", ])
```

## IM Escalar - avaliação
```{r}
fitMeasures(fit.scalar, c("chisq.scaled", "df.scaled", "pvalue.scaled", "rmsea.robust",
                        "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "cfi.robust",
                        "tli.robust", "srmr_mplus"))
```

## IM Estrita - especificação
```{r}
modelo.strict <- "
# Definir variáveis latentes para os 3 momentos
Pos_T1 =~ L1.1*PosAFF11 + L1.2*PosAFF21 + L1.3*PosAFF31; Pos_T2 =~ L1.1*PosAFF12 + L1.2*PosAFF22 + L1.3*PosAFF32; Pos_T3 =~ L1.1*PosAFF13 + L1.2*PosAFF23 + L1.3*PosAFF33
Neg_T1 =~ L2.1*NegAFF11 + L2.2*NegAFF21 + L2.3*NegAFF31; Neg_T2 =~ L2.1*NegAFF12 + L2.2*NegAFF22 + L2.3*NegAFF32; Neg_T3 =~ L2.1*NegAFF13 + L2.2*NegAFF23 + L2.3*NegAFF33

# Correlações entre resíduos ao longo do tempo
PosAFF11 ~~ PosAFF12 + PosAFF13; PosAFF12 ~~ PosAFF13; PosAFF21 ~~ PosAFF22 + PosAFF23; PosAFF22 ~~ PosAFF23; PosAFF31 ~~ PosAFF32 + PosAFF33; PosAFF32 ~~ PosAFF33; NegAFF11 ~~ NegAFF12 + NegAFF13; NegAFF12 ~~ NegAFF13; NegAFF21 ~~ NegAFF22 + NegAFF23; NegAFF22 ~~ NegAFF23; NegAFF31 ~~ NegAFF32 + NegAFF33; NegAFF32 ~~ NegAFF33

# Factors identification through reference measurement T1
Pos_T1 ~~ 1*Pos_T1; Pos_T2 ~~ NA*Pos_T2; Pos_T3 ~~ NA*Pos_T3
Neg_T1 ~~ Neg_T1; Neg_T2 ~~ NA*Neg_T2; Neg_T3 ~~ NA*Neg_T3

#equal intercepts
PosAFF11 ~ nu1.1*1; PosAFF12 ~ nu1.1*1; PosAFF13 ~ nu1.1*1; PosAFF21 ~ nu1.2*1; PosAFF22 ~ nu1.2*1; PosAFF23 ~ nu1.2*1; PosAFF31 ~ nu1.3*1; PosAFF32 ~ nu1.3*1; PosAFF33 ~ nu1.3*1
NegAFF11 ~ nu2.1*1; NegAFF12 ~ nu2.1*1; NegAFF13 ~ nu2.1*1; NegAFF21 ~ nu2.2*1; NegAFF22 ~ nu2.2*1; NegAFF23 ~ nu2.2*1; NegAFF31 ~ nu2.3*1; NegAFF32 ~ nu2.3*1; NegAFF33 ~ nu2.3*1

# Factors identification (mean) through reference measurment (T1)
Pos_T1 ~ 0*1; Pos_T2 ~ NA*1; Pos_T3 ~ NA*1; Neg_T1 ~ 0*1; Neg_T2 ~ NA*1; Neg_T3 ~ NA*1

#equal residual variances
PosAFF11 ~~ E1.1*PosAFF11; PosAFF12 ~~ E1.1*PosAFF12; PosAFF13 ~~ E1.1*PosAFF13
PosAFF21 ~~ E1.2*PosAFF21; PosAFF22 ~~ E1.2*PosAFF22; PosAFF23 ~~ E1.2*PosAFF23
PosAFF31 ~~ E1.3*PosAFF31; PosAFF32 ~~ E1.3*PosAFF32; PosAFF33 ~~ E1.3*PosAFF33
NegAFF11 ~~ E2.1*NegAFF11; NegAFF12 ~~ E2.1*NegAFF12; NegAFF13 ~~ E2.1*NegAFF13
NegAFF21 ~~ E2.2*NegAFF21; NegAFF22 ~~ E2.2*NegAFF22; NegAFF23 ~~ E2.2*NegAFF23
NegAFF31 ~~ E2.3*NegAFF31; NegAFF32 ~~ E2.3*NegAFF32; NegAFF33 ~~ E2.3*NegAFF33
"
```


## IM Estrita - estimação

```{r}
fit.strict <- cfa(modelo.strict, data = DF_mood, std.lv = T, missing = "fiml", estimator="MLR")
#summary(fit.strict, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)
all_params <- parameterEstimates(fit.conf, standardized = TRUE, rsquare = TRUE)
head(all_params[all_params$op == "~~", ])
```

## IM Estrita - avaliação
```{r}
fitMeasures(fit.strict, c("chisq.scaled", "df.scaled", "pvalue.scaled", "rmsea.robust",
                        "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "cfi.robust",
                        "tli.robust", "srmr_mplus"))
```


## Teste invariância: comparação de modelos

### Teste formal de invariância entre os modelos pode ser feito através do teste de razão de verossimilhança (LRT)
```{r}
summary(compareFit(fit.conf, fit.metric, fit.scalar, fit.strict))
```

### Interpretação
- O teste de razão de verossimilhança (LRT) compara a qualidade do ajuste dos modelos com e sem restrições
- Um valor de p significativo indica que o modelo mais restrito (com menos parâmetros) se ajusta significativamente pior aos dados do que o modelo menos restrito



## Implementação alternativa com recurso à função "measEq.syntax() do pacote semTools 
### Permite testar MI de forma mais automática
- Simplificação da sintaxe, reduzindo eventuais de erros de código
  
### Modelo Base (invariância configuracional)
```{r, eval=F}
model <- "
# Definir variáveis latentes para os 3 momentos
Pos_T1 =~ PosAFF11 + PosAFF21 + PosAFF31 
Pos_T2 =~ PosAFF12 + PosAFF22 + PosAFF32 
Pos_T3 =~ PosAFF13 + PosAFF23 + PosAFF33
Neg_T1 =~ NegAFF11 + NegAFF21 + NegAFF31 
Neg_T2 =~ NegAFF12 + NegAFF22 + NegAFF32 
Neg_T3 =~ NegAFF13 + NegAFF23 + NegAFF33

# Correlações entre resíduos ao longo do tempo
PosAFF11 ~~ PosAFF12 + PosAFF13; PosAFF12 ~~ PosAFF13; 
PosAFF21 ~~ PosAFF22 + PosAFF23; PosAFF22 ~~ PosAFF23; 
PosAFF31 ~~ PosAFF32 + PosAFF33; PosAFF32 ~~ PosAFF33
NegAFF11 ~~ NegAFF12 + NegAFF13; NegAFF12 ~~ NegAFF13; 
NegAFF21 ~~ NegAFF22 + NegAFF23; NegAFF22 ~~ NegAFF23; 
NegAFF31 ~~ NegAFF32 + NegAFF33; NegAFF32 ~~ NegAFF33
"
```

## IM Longitudinal
### Modelo Base (invariância configuracional)
```{r, eval=FALSE}
library(semTools)# se necessário: install.packages("semTools")
?measEq.syntax
```

```{r, eval=FALSE}
longFacNames <- list(Pos = c("Pos_T1","Pos_T2", "Pos_T3"), Neg = c("Neg_T1","Neg_T2", "Neg_T3"))
## configural model: no constraints across groups or repeated measures
syntax.config <- measEq.syntax(configural.model = model, data = DF_mood,
                               ID.fac = "std.lv", longFacNames = longFacNames)
summary(syntax.config) ## print a summary of model features
syntax.config <- as.character(syntax.config) # save as text
configural.fit <- cfa(syntax.config, data = DF_mood, meanstructure=T , std.lv = T, missing = "fiml", estimator="MLR")
summary(configural.fit, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)

fitMeasures(configural.fit, c("chisq.scaled", "df.scaled", "pvalue.scaled", "rmsea.robust",
                          "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "cfi.robust",
                          "tli.robust", "srmr_mplus"))
```

## IM Longitudinal
### Invariância fraca ou métrica (iguais loadings)  
```{r, eval=FALSE}
syntax.scalar <- measEq.syntax(configural.model = syntax.config, data = DF_mood,
                               ID.fac = "std.lv", longFacNames = longFacNames,
                               long.equal  = c("loadings", "intercepts"))
summary(syntax.scalar ) # summarize model features
mod.scalar <- as.character(syntax.scalar ) # save as text
scalar.fit <- cfa(mod.scalar, data = DF_mood, meanstructure=T, std.lv = T, missing = "fiml", estimator="MLR")
summary(scalar.fit, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)

summary(compareFit(configural.fit, metric.fit))
```

## IM Longitudinal
### Invariância forte ou escalar (iguais loadings e intercepts)  
```{r, eval=FALSE}
syntax.scalar <- measEq.syntax(configural.model = syntax.config, data = DF_mood,
                               ID.fac = "std.lv", longFacNames = longFacNames,
                               long.equal  = c("loadings", "intercepts"))
summary(syntax.scalar ) # summarize model features
mod.scalar <- as.character(syntax.scalar ) # save as text
scalar.fit <- cfa(mod.scalar, data = DF_mood, meanstructure=T, meanstructure=T , std.lv = T, missing = "fiml", estimator="MLR")
summary(scalar.fit, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)

summary(compareFit(metric.fit, scalar.fit))
```

## IM Longitudinal
### Invariância estrita (iguais loadings + intercepts + residuals)  
```{r, eval=FALSE}
syntax.strict <- measEq.syntax(configural.model = syntax.config, data = DF_mood,
                               ID.fac = "std.lv", longFacNames = longFacNames,
                               long.equal  = c("loadings", "intercepts", "residuals"))
summary(syntax.strict ) # summarize model features
mod.strict <- as.character(syntax.strict ) # save as text
strict.fit <- cfa(mod.strict, data = DF_mood, meanstructure=T, meanstructure=T , std.lv = T, missing = "fiml", estimator="MLR")
summary(strict.fit, standardized=TRUE, fit.measures=TRUE, rsquare = TRUE)

summary(compareFit(scalar.fit, strict.fit))
```


# Exercício prático - Parte 1 (ver "LongSEM_ex.html")

# Modelos de crescimento latente (LGC)

## LGC - Introdução  
Os LGC focam-se primariamente na análise das **trajetórias de mudança** que caracterizam um grupo de pessoas numa determinada variável 

Estas trajetórias são caracterizadas de acordo com 2 parâmetros:  
  (1) Média de crescimento; (2) Variação (variância) inter-individual  

*Sendo possível caracterizar os padrões médios de mudança de um determinado grupo de pessoas, é também útil reconhecer que na maioria das situações diferentes pessoas apresentam padrões de mudança distintos* 

```{r, out.width = "400px", echo = FALSE}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\plot_LGC.jpg")
```


## LGC - Introdução  
Os modelos LGC respondem a três questões essenciais (Bollen & Curran, 2006):  
  
  - Como se caracteriza a trajetória média de mudança de um grupo de sujeitos numa variável?  
      *Será que existem mudanças significativas ao longo do tempo e como se podem caracterizar essas mudanças?*  
        
  - A trajetória média estimada é suficiente para explicar as mudanças nos diferentes padrões individuais de trajetórias?  
      *Será que existe variabilidade intra-individual nos níveis iniciais (i.e., intercept) e taxa mudança (i.e., slope)?*  
  
  - Se existe variabilidade nas trajetórias individuais, será que podemos recorrer a outras variáveis para explicar essa variabilidade?  
      *Que variáveis são necessárias para explicar as diferenças individuais (i.e., variância) nos momentos iniciais e trajetórias de mudança?*


## Modelos de crescimento latente
Estes modelos procuram explicar uma variável em função do tempo, descrevendo:  
  - Nível inicial e trajetória de mudança dos indivíduos  
  - Diferenças inter-individuais nestes parâmetros
  
Oferecem uma forma flexível de testar o valor preditivo de outras variáveis face às trajetórias   

Os modelos LGC podem assumir crescimento linear ou não linear  

```{r, out.width = "300px", echo = FALSE}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\plot_poli.jpg")
```


## Modelo de crescimento latente
Definido pelas seguintes equação multinível genéricas:  

**Nível 1 (mudança intraindividual associada ao tempo - within-subject):**  
$${y_{ti}} = \beta_{0i} + \beta_{1i}x_{ti} + r_{ti}$$
LEGENDA:  
  - *i* = indivíduos & *t* = ocasião de medida;  
  - ${Y_{ti}}$ = score do indivíduo *i* na variável *y* no tempo *t*;  
  - $x_{ti}$ = variável que define a unidade de tempo;  
  - $\beta_{0i}$ = o intercept do indivíduo *i*, isto é, o score de *y* no primeiro momento de avaliação, quando *t* é igual a zero;  
  - $\beta_{1i}$ = a slope do indivíduo *i*, definida pela variável *t*. Corresponde à trajetória de crescimento de cada um dos indivíduos ao longo do tempo;  
  - $r_{ti}$ = resíduo associado ao score do indivíduo *i* na ocasião *t* - discrepância entre a trajetória individual estimada e o valor observado;


## Modelo de crescimento latente  
**Nível 1 (mudança intraindividual associada ao tempo - within-subject):**  
$${y_{ti}} = \beta_{0i} + \beta_{1i}x_{ti} + r_{ti}$$

```{r, echo=FALSE, fig.height = 3.5, fig.width = 7}
dat_x <- data.frame(time=0:4, y=c(2.2,2,2.8,3,4))
plot(dat_x$time, dat_x$y)
abline(lm(dat_x$y~dat_x$time))
```  


## Modelo de crescimento latente  
O tempo pode não explicar todas as diferenças ao nível...  
- do ponto de partida ($\beta_{0i}$)  
- da trajetória de mudança ($\beta_{1i}$)  

```{r, out.width = "400px", echo = FALSE}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\plot_LGC.jpg")
```

Para melhor representar os nossos dados, torna-se necessário integrar no modelo a variabilidade individual tanto ao nível de $\beta_{0i}$ como de $\beta_{1i}$ 



## Modelo de crescimento latente  
### Nível 2 (variação interindividuais, between-subjec): INTERCEPT   
$$\beta_{0i} = \gamma_{00} + u_{0i}$$

LEGENDA:  
  - *i* = indivíduos;  
  - $\beta_{0i}$ = intercept do indivíduo *i*, valor esperado de *Y* quando *t*=0;  
  - $\gamma_{00}$ = média de todos os intercepts, ou intercept da equação de nível 2 predizendo $\beta_{0i}$, o intercept da equação de nível 1;    
  - $u_{0i}$ = desvio de cada indivíduo *i* face ao intercept médio ou variância da slope;  

NOTA: a esta equação podem ser acrescentados parâmetros (eg., $\gamma_{10}$, $\gamma_{20}$...) que potencialmente expliquem $\beta_{0i}$


## Modelo de crescimento latente  
### Nível 2 (variação interindividuais, between-subjec): INTERCEPT  
$$\beta_{0i} = \gamma_{00} + u_{0i}$$
```{r, echo=FALSE, fig.height = 3.5, fig.width = 7}
dat_x <- data.frame(time=rep(0:4,5), y=c(jitter(seq(1.0, 5.0,length.out=5)),
                                         jitter(seq(1.5, 5.5,length.out=5)), 
                                         jitter(seq(2.0, 6.0,length.out=5), factor=2),
                                         jitter(seq(3.0, 7.0,length.out=5), factor=3),
                                         jitter(seq(4.5, 8.5,length.out=5), factor=2)))

plot(dat_x$time, dat_x$y)
abline(lm(y~time, data=dat_x[1:5,]))
abline(lm(y~time, data=dat_x[6:10,]))
abline(lm(y~time, data=dat_x[11:15,]))
abline(lm(y~time, data=dat_x[16:20,]))
abline(lm(y~time, data=dat_x[21:26,]))
abline(lm(y~time, data=dat_x), col="brown", lwd=4)
```


## Modelo de crescimento latente  
### Nível 2 (variação interindividuais, between-subjec): SLOPE    
$$\beta_{1i} = \gamma_{10} + u_{1i}$$
LEGENDA:  
  - *i* = indivíduos;  
  - $\beta_{1i}$ = a slope do indivíduo *i*, definida pela variável *t*. Corresponde à trajetória de crescimento de cada um dos indivíduos ao longo do tempo;     
  - $\gamma_{10}$ = média de todas as slope, ou intercept da equação de nível 2 predizendo $\beta_{1i}$, a slope da equação de nível 1;    
  - $u_{1i}$ = desvio de cada indivíduo *i* face à slope média ou variância da slope;  

NOTA: a esta equação podem ser acrescentados parâmetros (eg., $\gamma_{10}$, $\gamma_{20}$...) que potencialmente expliquem $\beta_{1i}$

## Modelo de crescimento latente 
### Nível 2 (variação interindividuais, between-subjec): SLOPE    
$$\beta_{1i} = \gamma_{10} + u_{1i}$$
```{r, echo=FALSE, fig.height = 3.5, fig.width = 7}
dat_x <- data.frame(time=rep(0:4,5), y=c(jitter(seq(3.0, 6.0,length.out=5)),
                                         jitter(seq(3.0, 5.5,length.out=5)), 
                                         jitter(seq(3.0, 4.6,length.out=5), factor=2),
                                         jitter(seq(3.0, 2.8,length.out=5), factor=3),
                                         jitter(seq(3.0, 2.4,length.out=5), factor=2)))

plot(dat_x$time, dat_x$y)
abline(lm(y~time, data=dat_x[1:5,]))
abline(lm(y~time, data=dat_x[6:10,]))
abline(lm(y~time, data=dat_x[11:15,]))
abline(lm(y~time, data=dat_x[16:20,]))
abline(lm(y~time, data=dat_x[21:26,]))
abline(lm(y~time, data=dat_x), col="brown", lwd=4)
```


## Modelo de crescimento latente
### Nível 1 e 2 (variação intra e interindividuais): INTERCEPT & SLOPE   
$${y_{ti}} = (\gamma_{00} + u_{0i}) + (\gamma_{10} + u_{1i})x_{ti} + r_{ti}$$
$${y_{ti}} = \gamma_{00} + \gamma_{10}x_{ti} + u_{0i} + u_{1i}x_{ti} + r_{ti}$$
O modelo completo incluí assim 3 componentes de erro:   
- $r_{ti}$ que corresponde a diferenças intraindividuais (**erro na equação de nível 1**)  
- $u_{0i}$ e $u_{1i}$ que corresponde a diferenças interindividuais ao nível do intercept e slope (**erros nas equações de nível 2**)  


## Modelos de crescimento latente

$${y_{ti}} = \gamma_{00} + \gamma_{10}x_{ti} + u_{0i} + u_{1i}x_{ti} + r_{ti}$$

```{r, echo=FALSE, fig.height = 4.5, fig.width = 7}

dat_x <- data.frame(time=rep(0:4,5), y=c(jitter(seq(2.5, 6,length.out=5)),
                                         jitter(seq(2, 5.5,length.out=5)), 
                                         jitter(seq(3, 4.5,length.out=5), factor=2),
                                         jitter(seq(4, 3,length.out=5), factor=3),
                                         jitter(seq(1.5, 4.5,length.out=5), factor=2)))

plot(dat_x$time, dat_x$y)
abline(lm(y~time, data=dat_x[1:5,]))
abline(lm(y~time, data=dat_x[6:10,]))
abline(lm(y~time, data=dat_x[11:15,]))
abline(lm(y~time, data=dat_x[16:20,]))
abline(lm(y~time, data=dat_x[21:26,]))
abline(lm(y~time, data=dat_x), col="brown", lwd=4)
```


## Modelo de crescimento latente

A equação da regressão multinível...   
$${y_{ti}} = \gamma_{00} + \gamma_{10}x_{ti} + u_{0i} + u_{1i}x_{ti} + r_{ti}$$
...é reproduzida no diagrama SEM para o modelo LGC:     

```{r, out.width = "450px", echo = FALSE}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\LGC_diagram1.jpg")
```

$${y_{ti}} = \alpha_{1} + \alpha_{2}\lambda_{t2} + \zeta_{1i} + \zeta_{2i}\lambda_{ti} + \varepsilon_{ti}$$

## Modelo de crescimento latente
A especificação do modelo fica completa com a codificação de tempo (*t* na equação anterior)  
  - Este codificação irá definir a forma da slope: linear, quadrática, cúbica...  

Codificação **linear** de *t* para 4 ocasiões  
```{r, out.width = "350px", echo = FALSE}
knitr::include_graphics("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Figures\\LGC_diagram2.jpg")
```

- Intercept fixado a 1 nas diferentes ocasiões de medida  
- Slope fixadas a 0, 1, 2 e 3 respetivamente à primeira, segunda, terceira e quarta ocasião de medida  


## Modelo de crescimento latente

**O intercept ($\beta_{0i}$)**:  
 - Loadings fixados a 1 nas quatro ocasiões de medida   
 - Constante que captura o valor médio de ${y_{ti}}$ quando a variável preditora, neste caso **tempo**, assume o valor de zero.  

**A slope ($\beta_{1i}$)**:  
 - Loadings são fixados a 0, 1, 2 e 3, respetivamente no tempo 1, 2, 3 e 4    
 - Esta codificação reflete a linearidade do crescimento latente ao longo dos 4 momentos  


## Modelo de crescimento latente - Sumário  
Os modelos LGC caracterizam as mudanças individuais de acordo com:  
  - médias do intercept e slope  
  - variação inter individual  
  
Como estes **parâmetros são tratado como variáveis latentes**, podem ser modelados de forma muito flexível 

*De seguida, apresentamos alguns exemplos de como esta modelação pode ser executada com recurso ao R e ao pacote lavaan.*





## Especificação, estimação e avaliação de Modelos de Crescimento Latente (LGC) no R    
Nos exemplos que se seguem recorremos mais uma vez à base de dados apresentada por Todd Little (2013) no seu livro *Longitudinal structural equation modeling*.  
```{r, echo=TRUE, eval=FALSE, include=FALSE}

DF_LGM <- read.table("C:\\Users\\tiago\\Google Drive\\FPCEUP\\R trainning\\PDPsi\\R crash course_DATA\\L9.Panas.4Wave.dat")
names(DF_LGM) <- c("PosAFF_T1", "PosAFF_T2", "PosAFF_T3", "PosAFF_T4", "NegAFF_T1", "NegAFF_T2", 
                   "NegAFF_T3", "NegAFF_T4", "gender_male", "Black", "Hispanic", "Other")

head(DF_LGM)

summary(DF_LGM)

write.csv(DF_LGM, "G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Data\\lgm.csv", row.names=FALSE)

```

Usamos o código seguinte para importar esta base de dados:  
```{r}
DF_LGM <- read.csv("G:\\My Drive\\FPCEUP\\AtividadeDocente\\Longitudinal_SEM\\LongSEM_Data\\lgm.csv")
```



* Algumas características desta base de dados  
```{r, eval=FALSE}
names(DF_LGM)
class(DF_LGM)
str(DF_LGM)
```

## Estatística descritiva  
```{r}
library(psych) # se necessário: install.packages("psych")
psych::describe(DF_LGM[ ,1:8])
```

## Estatística descritiva  
```{r, fig.height = 3, fig.width = 7}
#Visualização de dados 
library(ggplot2) # se necessário: install.packages("ggplot2")

DF_pos <- data.frame(var=c(rep("PosAFF_T1", nrow(DF_LGM)), rep("PosAFF_T2", nrow(DF_LGM)), 
                           rep("PosAFF_T3", nrow(DF_LGM)), rep("PosAFF_T4", nrow(DF_LGM))), 
                     value = c(DF_LGM$PosAFF_T1, DF_LGM$PosAFF_T2, DF_LGM$PosAFF_T3, DF_LGM$PosAFF_T4))
ggplot(DF_pos, aes(x=var,y=value, fill=var)) +
  geom_boxplot() +
  geom_jitter(width=0.08, alpha=0.03)
```

## Estatística descritiva
```{r, fig.height = 3, fig.width = 7}
DF_neg <- data.frame(var=c(rep("NegAFF_T1", nrow(DF_LGM)), rep("NegAFF_T2", nrow(DF_LGM)), 
                           rep("NegAFF_T3", nrow(DF_LGM)), rep("NegAFF_T4", nrow(DF_LGM))), 
                     value = c(DF_LGM$NegAFF_T1, DF_LGM$NegAFF_T2, DF_LGM$NegAFF_T3, DF_LGM$NegAFF_T4))

ggplot(DF_neg, aes(x=var,y=value, fill=var)) +
  geom_boxplot() +
  geom_jitter(width=0.08, alpha=0.03)
```

## As funções **growth()** e **sem()** (OPCIONAL)  
O lavaan disponibiliza a função **growth()** para estimação de modelos de crescimento latente (LGC)  
  - Esta função deixará de fazer parte do pacote em breve  
  - As funções **sem()** e **growth()** são muito semelhantes   
      - Ao contrario da função **sem()**, na função **growth()** assume automaticamente *meanstructure=TRUE*, fixa a zero os intercepts observados e estima livremente as médias da variáveis latentes. 

A especificação e estimação de um modelo LGC com quatro ocasiões de medida usando a função **growth()** é feita da seguinte forma:

```{r}
modelo.8 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4
"
```

## As funções **growth()** e **sem()** (OPCIONAL)  
Intercept definido fixando os seus loadings a 1 nos quatro momentos de avaliação  

Slope é definida fixando a 0, 1, 2 e 3  

A estimação do modelo é feita da seguinte forma:
```{r}
fit.8 <- growth(modelo.8, data=DF_LGM)
```
```{r, eval=FALSE}
summary(fit.8, standardized=T, fit.measures=T)
```

## As funções **growth()** e **sem()** (OPCIONAL)  
O mesmo modelo é estimado com a função **sem()**:  
```{r}
modelo.8.1 <- "
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## fixar os intercepts das variáveis observadas a zero e 
## libertar as médias latentes (intecept e crescimento médio)
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1
"
```  
*Explicitar a estimação livre das médias latentes e fixar os intercept observados a 0*  
```{r}
fit.8.1 <- sem(modelo.8.1, data=DF_LGM)
```
```{r, eval=FALSE}
summary(fit.8.1, standardized=T, fit.measures=T)
```

## As funções **growth()** e **sem()** (OPCIONAL)  
Os dois modelos estimados pelas funções **growth()** e **sem()** são idênticos   
```{r}
summary(compareFit(fit.8, fit.8.1, nested=FALSE))
```
Tal como recomendado, iremos usar a função **sem()** nos exemplos que se seguem  

## Step 1: Modelo não condicionado  
O teste de um modelo de LGC frequentemente inicia-se com a avaliação de um modelo não condicionado  
    - Este modelo não impõe qualquer trajetória de crescimento sendo usado como modelo de base  
    
```{r, fig.height = 3.5, fig.width = 6, echo=F}
modelo.9 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + NegAFF_T2 + NegAFF_T3 + 1*NegAFF_T4

## intercepts e médias
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1
"
fit.9 <- sem(modelo.9, data=DF_LGM, meanstructure=TRUE)
# diagrama do modelo
semPaths(fit.9, whatLabels="est", title = FALSE, curvePivot = TRUE, layout="tree", intercepts=T, rotation=2, nCharNodes=3, sizeMan=10, sizeLat= 7, residuals=T, exoVar=F, edge.color=9)
title("Modelo de Crescimento Latente não Condicionado", line = 3)
```

## Step 1: Modelo não condicionado  
Para especificar este modelo, apenas fixar dois dos quatro loadings da slope, libertando os restantes  

```{r}
modelo.9 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + NegAFF_T2 + NegAFF_T3 + 1*NegAFF_T4

## intercepts e médias
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1
"
fit.9 <- sem(modelo.9, data=DF_LGM, meanstructure=TRUE)
```

```{r, eval=FALSE}
#sumário do modelo
summary(fit.9, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)
```

## Step 1: Modelo não condicionado  
Este modelo não condicionado permite explorar a forma da trajetória de crescimento

*Se analisarmos os loadings (não estandardizados) da slope nos diferentes momentos, podemos inferir uma trajetória relativamente linear: 0 em t1, .27 em t2, .70 em t3 e 1 em t4.*

Podemos confirmar a linearidade da trajetória, testando o ajustamento do **modelo condicionado** aos dados

## STEP 2: Modelo condicionado  
O modelo condicionado impõem uma slope linear, fixando todos os seus loadings a 0, 1, 2 e 3    
```{r, echo=F, fig.height = 4.5, fig.width = 7}
modelo.10 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## intercepts e médias
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1
"
fit.10 <- sem(modelo.10, data=DF_LGM, meanstructure=TRUE)
# diagrama do modelo
semPaths(fit.10, whatLabels="est", title = FALSE, curvePivot = TRUE, layout="tree", intercepts=T, rotation=2, nCharNodes=3, sizeMan=10, sizeLat= 7, residuals=T, exoVar=F, edge.color=9)
title("Modelo de Crescimento Latente Condicionado", line = 3)
```

## STEP 2: Modelo condicionado  
```{r}
modelo.10 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## intercepts e médias
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1
"
fit.10 <- sem(modelo.10, data=DF_LGM, meanstructure=TRUE)
```

## STEP 2: Modelo condicionado  
```{r, eval=FALSE}
#sumário do modelo
summary(fit.10, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)
```  

Este modelo pode ser retido uma vez que não difere significativamente do modelo não condicionado, sendo mais mais parcimonioso  
```{r}
anova(fit.9, fit.10)
```

## Interpretação dos resultados  
Pelo sumário do modelo anterior verificamos que: 
  
  - Tanto o intercept (*b* = 2.09) como a slope (*b* = -.10) apresentam valores significativos  
    - *Nível médio de afeto negativo de 2.09 em T0 com decréscimo linear a uma taxa média de -.10 (por ano)*    
  
  - As variâncias do intercept (*b* = .27) e slope (*b* = .01) também são ambas significativas  
    - Existência de variabilidade entre indivíduos, tanto no que toca ao níveis iniciais de afeto negativo como às trajetórias de mudança   
    
    
## Interpretação dos resultados  
Correlação significativa entre o intercept e a slope b (*r* = -.71).  
  - Com **slope positiva** uma correlação negativa sugere que sujeitos com níveis iniciais mais elevados de afeto apresentam um crescimento menor ao longo do tempo.  
  - Com **slope negativa** (há um decréscimo ao longo do tempo), uma **correlação negativa** com o intercept indica que:  
    - Scores de pessoas com níveis *iniciais de afeto mais elevados* tendem a *decrescer mais* ao longo do tempo (slope mais negativa).  
    - Scores de pessoas com níveis *iniciais de afeto mais baixo*s deverão *decrescer menos* ao longo do tempo (slope menos negativa).  
  
Podemos também interpretar o R-square.  
  - Ligeiro decréscimo da variância explicada dos indicadores pelo fator (slope) ao longo do tempo 

## LGC: Constrangimentos ao modelo  
É prática frequente impor constrangimentos ao modelo com o objetivo de aumentar a sua parcimónia.    
  - Igualar os resíduos dos indicadores - correspondência com pressuposto da *homogeneidade das variâncias* nos modelos clássicos de regressão.

```{r, fig.height = 4, fig.width = 6, echo=FALSE}
modelo.10.1 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## intercepts e médias
intercept ~ 1; slope ~ 1
NegAFF_T1 ~ 0*1; NegAFF_T2 ~ 0*1; NegAFF_T3 ~ 0*1; NegAFF_T4 ~ 0*1

## Fixar as variâncias residuais ao mesmo valor
NegAFF_T1 ~~ res1*NegAFF_T1; NegAFF_T2 ~~ res1*NegAFF_T2
NegAFF_T3 ~~ res1*NegAFF_T3; NegAFF_T4 ~~ res1*NegAFF_T4
"
fit.10.1 <- sem(modelo.10.1, data=DF_LGM, meanstructure=TRUE)

# diagrama do modelo
semPaths(fit.10.1, whatLabels="est", title = FALSE, curvePivot = TRUE, layout="tree", intercepts=T, rotation=2, nCharNodes=3, sizeMan=10, sizeLat= 7, residuals=T, exoVar=F, edge.color=9)
title("Modelo de Crescimento Latente com Constrangimentos", line = 3)
```

## LGC: Constrangimentos ao modelo  
```{r, eval=FALSE}
modelo.10.1 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## intercepts e médias
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1

## Fixar as variâncias residuais ao mesmo valor
NegAFF_T1 ~~ res1*NegAFF_T1
NegAFF_T2 ~~ res1*NegAFF_T2
NegAFF_T3 ~~ res1*NegAFF_T3
NegAFF_T4 ~~ res1*NegAFF_T4
"
fit.10.1 <- sem(modelo.10.1, data=DF_LGM, meanstructure=TRUE)

#sumário do modelo
summary(fit.10.1, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)

```

## LGC: Constrangimentos ao modelo  
Os resultados da função **compareFit()** indicam que os dois modelos (com e sem constrangimentos) diferem significativamente no seu ajustamento aos dados  
  - O ajustamento piora com os constrangimentos    
```{r}
summary(compareFit(fit.10, fit.10.1))
```

## LGC: Visualização (OPCIONAL)  
As seguintes linhas de código são opcionais e servem para visualizar os valores individuais e médios estimados pelo modelo.  
```{r}
DF_FIT.10.1 <- as.data.frame(cbind(1:nrow(DF_LGM), predict(fit.10.1)))
names(DF_FIT.10.1)[1] <- "ID"
DF_FIT.10.1$ID <- rep("subjets", nrow(DF_FIT.10.1))
DF_FIT.10.1.sel <- DF_FIT.10.1[sample(1:nrow(DF_FIT.10.1),100), ]

DF_coef_fit.10.1 <- as.data.frame(matrix(coef(fit.10.1)[1:2], ncol=2, byrow=TRUE))
DF_coef_fit.10.1 <- as.data.frame(c("Average Est", DF_coef_fit.10.1), col.names=names(DF_FIT.10.1))

```

## LGC: Visualização (OPCIONAL)  
```{r, warning= FALSE, fig.height = 4, fig.width = 6}
ggplot() + 
  scale_y_continuous(limits=c(0,4)) + 
  geom_abline(data= DF_FIT.10.1.sel, aes(slope=slope, intercept=intercept), colour="grey") +
  geom_abline(data= DF_coef_fit.10.1, aes(slope=slope, intercept=intercept, colour="estimate"), size=1) +
  theme(legend.title = element_blank()) +
  scale_x_continuous("TIME", limits=c(0,10)) 
```

## LGC: Modelo de crescimento com covariáveis fixas no tempo  
Os modelos LGC permitem incluir covariáveis para explicar a variância do intercept e da slope  
No modelo seguinte estimamos o efeito de 3 variáveis dicotómicas:  
  - "gender_male";  
  - "Black";  
  - "Hispanic";  
  
## LGC: Modelo de crescimento com covariáveis fixas no tempo  
```{r, fig.height = 5, fig.width = 8, echo = FALSE}
modelo.11 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## intercepts e médias
intercept ~ 1
slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1

## Fixar as variâncias residuais ao mesmo valor
NegAFF_T1 ~~ res1*NegAFF_T1; NegAFF_T2 ~~ res1*NegAFF_T2
NegAFF_T3 ~~ res1*NegAFF_T3; NegAFF_T4 ~~ res1*NegAFF_T4

# Covariáveis
intercept ~ gender_male + Black + Hispanic
slope ~ gender_male + Black + Hispanic
"
fit.11 <- sem(modelo.11, data=DF_LGM, meanstructure=TRUE)

# diagrama do modelo
semPaths(fit.11, whatLabels="std", title = FALSE, curvePivot = TRUE, layout="tree", intercepts=T, rotation=2, nCharNodes=3, sizeMan=10, sizeLat= 7, residuals=T, exoVar=F, edge.color=9)
title("LGC model com Covariáveis Fixas", line = 3)
```  

## LGC: Modelo de crescimento com covariáveis fixas no tempo
```{r}
modelo.11 <- "
## média inicial e trajetória linear de crescimento
intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

## intercepts e médias
intercept ~ 1; slope ~ 1
NegAFF_T1 ~ 0*1; NegAFF_T2 ~ 0*1; NegAFF_T3 ~ 0*1; NegAFF_T4 ~ 0*1

## Fixar as variâncias residuais ao mesmo valor
NegAFF_T1 ~~ res1*NegAFF_T1; NegAFF_T2 ~~ res1*NegAFF_T2; 
NegAFF_T3 ~~ res1*NegAFF_T3; NegAFF_T4 ~~ res1*NegAFF_T4

# Covariáveis
intercept ~ gender_male + Black + Hispanic
slope ~ gender_male + Black + Hispanic
"
fit.11 <- sem(modelo.11, data=DF_LGM, meanstructure=TRUE)
```  

## LGC: Modelo de crescimento com covariáveis fixas no tempo

```{r, eval=FALSE}
#sumário do modelo
summary(fit.11, fit.measures=TRUE, rsquare=TRUE)
```

Os resultados sugerem efeitos significativos de género e etnia (afro-americana) tanto no intercept como na slope.  
  - Homens com níveis iniciais mais elevados de afeto negativo quando comparados com as mulheres.  
  - Quando comparados com outras etnias, afro-americanos apresentam níveis iniciais mais elevados de afeto negativo, seguido de um menor decréscimo ao longo do tempo.  

## LGC: Modelo de crescimento linear multivariado   
Um exemplo adicional das potencialidade analíticas dos modelos de crescimento latente consiste na possibilidade de estimar trajetórias de crescimento de diferentes variáveis  
  
  - No modelo seguintes, para além do afeto negativo, estimamos a trajetória de crescimento de outra variável, afeto positivo.  


## LGC: Modelo de crescimento linear multivariado  
```{r, fig.height = 6, fig.width = 9, echo = FALSE}
modelo.12 <- "
## média inicial e trajetória linear de crescimento
Neg_intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
Neg_slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4

Pos_intercept =~ 1*PosAFF_T1 + 1*PosAFF_T2 + 1*PosAFF_T3 + 1*PosAFF_T4
Pos_slope =~ 0*PosAFF_T1 + 1*PosAFF_T2 + 2*PosAFF_T3 + 3*PosAFF_T4

## intercepts e médias
Neg_intercept ~ 1
Neg_slope ~ 1
NegAFF_T1 ~ 0*1
NegAFF_T2 ~ 0*1
NegAFF_T3 ~ 0*1
NegAFF_T4 ~ 0*1

Pos_intercept ~ 1
Pos_slope ~ 1
PosAFF_T1 ~ 0*1
PosAFF_T2 ~ 0*1
PosAFF_T3 ~ 0*1
PosAFF_T4 ~ 0*1

## Fixar as variâncias residuais ao mesmo valor
NegAFF_T1 ~~ res1*NegAFF_T1; NegAFF_T2 ~~ res1*NegAFF_T2
NegAFF_T3 ~~ res1*NegAFF_T3; NegAFF_T4 ~~ res1*NegAFF_T4

PosAFF_T1 ~~ res2*PosAFF_T1; PosAFF_T2 ~~ res2*PosAFF_T2
PosAFF_T3 ~~ res2*PosAFF_T3; PosAFF_T4 ~~ res2*PosAFF_T4

"
fit.12 <- sem(modelo.12, data=DF_LGM, meanstructure=TRUE)

# diagrama do modelo
semPaths(fit.12, whatLabels="std", title = FALSE, curvePivot = TRUE, layout="tree", intercepts=T, rotation=2, nCharNodes=3, sizeMan=10, sizeLat= 7, residuals=T, exoVar=F, edge.color=9)
title("Modelo de Crescimento Latente Multivariado", line = 3)

#sumário do modelo
summary(fit.12, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)
```

## LGC: Modelo de crescimento linear multivariado  
```{r}
modelo.12 <- "
## média inicial e trajetória linear de crescimento
Neg_intercept =~ 1*NegAFF_T1 + 1*NegAFF_T2 + 1*NegAFF_T3 + 1*NegAFF_T4
Neg_slope =~ 0*NegAFF_T1 + 1*NegAFF_T2 + 2*NegAFF_T3 + 3*NegAFF_T4
Pos_intercept =~ 1*PosAFF_T1 + 1*PosAFF_T2 + 1*PosAFF_T3 + 1*PosAFF_T4
Pos_slope =~ 0*PosAFF_T1 + 1*PosAFF_T2 + 2*PosAFF_T3 + 3*PosAFF_T4

## médias
Neg_intercept ~ 1; Neg_slope ~ 1
Pos_intercept ~ 1; Pos_slope ~ 1

# intercepts 
NegAFF_T1 ~ 0*1; NegAFF_T2 ~ 0*1; NegAFF_T3 ~ 0*1; NegAFF_T4 ~ 0*1; 
PosAFF_T1 ~ 0*1; PosAFF_T2 ~ 0*1; PosAFF_T3 ~ 0*1; PosAFF_T4 ~ 0*1

## Fixar as variâncias residuais ao mesmo valor
NegAFF_T1 ~~ res1*NegAFF_T1; NegAFF_T2 ~~ res1*NegAFF_T2
NegAFF_T3 ~~ res1*NegAFF_T3; NegAFF_T4 ~~ res1*NegAFF_T4
PosAFF_T1 ~~ res2*PosAFF_T1; PosAFF_T2 ~~ res2*PosAFF_T2
PosAFF_T3 ~~ res2*PosAFF_T3; PosAFF_T4 ~~ res2*PosAFF_T4
"
fit.12 <- sem(modelo.12, data=DF_LGM, meanstructure=TRUE)
```

## LGC: Modelo de crescimento linear multivariado  
```{r, eval=FALSE}
#sumário do modelo
summary(fit.12, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)
```

*Este modelo estima os intercepts e slopes médias e suas variâncias para afeto negativo e positivo, bem como a correlação entre as trajetórias das duas variáveis*  
  
  - Correlação negativa entre os níveis médios iniciais de afeto negativo e níveis médios iniciais de afeto positivo  
  
  

# Exercício prático - Parte 2 (ver "LongSEM_ex.html")
